# Introduction

 [by Vlad Khazin](https://www.linkedin.com/in/vkhazin)
 
## Overview

There are university, college and online courses for software development as a discipline.
This course's focus is to extend the general principles of computer science into enterprise application development practices, explore common patterns and to recognize common anti-patterns.

Enterprise software is diverse, built using different programming languages, leveraging different middleware and back-ends, utilizing divergent user interfaces, and, generally, is messy.
There is no single solution, programming language or even a single vendor that offers the best solution for every problem.
The agenda of the course is a mile-wide and an inch-deep coverage of software development practices, programming languages, types of user-interfaces, and a variety of databases.

You will come out of the course with guidance to recognize a category of enterprise software you are dealing with or need to build.
You will feel more comfortable collaborating with application developers as well as will learn to recognize software development pains and common obstacles.
You will experience different approaches with pragmatic hands-on labs and group discussions.
You will come out more comfortable dealing with typical and/or atypical enterprise software.

There is no magic wand at the end of the course to resolve a production issue you may have been struggling with. 
Or a crystal ball to predict the delivery of a software project that has been falling behind for months.
There are recipes to consider and common practices to deal with the ever-changing IT landscape.
There is an insight into the SDLC to deliver your next initiative more predictably.

Anti-patterns are common, tech debt is a norm, nothing ever seems to run smoothly - let's learn how to reduce the symptoms until a vaccine is here.


## Audience

* Software developers familiar with coding and looking to extend industry knowledge 
* Network engineers, system operators, and quality assurance personnel desiring to widen the knowledge
* Technical product owners aspiring to extend the understanding of trade-offs in enterprise development

## Objectives

* Review common application types: batch, daemon/service, database, cli, desktop, client-server, web, mobile, and edge
* Get familiar with programming paradigms: procedural, OOP, declarative, event-driven, and functional
* Understand implications of selecting statically vs. dynamically typed languages
* Assess common programming languages and their suitability for business requirements
* Analyze commons trade-offs of multi-user, multi-layer and distributed applications
* Explore prevalent communication patterns, e.g.: Web Services, Messaging, and Publisher/Subscriber
* Examine common software architecture patterns and their evolution
* Define best coding practices from the enterprise point of view
* Experiment with common programming languages, application/web platforms and databases to draw a comparison
* Discuss Software Development Life Cycle
* Clarify the need for configuration and secrets management
* Dissect common development anti-patterns and prevalent technical debt
* Consider application hosting options: self-managed, IaaS, PaaS, containers, and serverless
* Introduce the importance of automation for deployment, testing, and operation

## Prerequisites

* Information Technology background: education or adequate hands-on experience
* Recent hands-on experience writing scripts and/or programming
* Familiarity with programming concepts: functions, arguments, variables, conditions, and loops 
* Access to AWS personal account where a free trial is sufficient

## Outline

### Introduction

* From coding to programing
* Source control management
* Development in a team
* Artifacts
* Testing methods
* Production

### Application Types

* Batch
* Daemon or Service
* Command Line Interface
* Desktop GUI
* Client-Server Application
* Web-based GUI
* Mobile Application
* IoT & Robotic 
* SDK & API's
* Middleware
* Database

### Programming Paradigms

* So many languages so little time
* Procedural
* Object-Oriented
* Declarative
* Event-driven
* Functional

### Types of Languages

* Compiled vs. interpreted
* Types of compilation
* Statically vs. dynamically typed
* Statically vs. dynamically linked

### Selecting a Language

* Performance constraints
* Footprint consideration
* Data types support
* Market popularity
* Team familiarity
* Long-term TCO
* Tooling

### Architectural Trades-Offs

* Single user vs. multi-user
* Single tier vs. multi-tier
* Centralized vs. distributed
* Scale-up vs. scale-out
* Common troubles 

### Communication Patterns

* History of distributed computing
* From RPC to API
* From shared database to services
* Soap, Rest, & Restful
* Sync vs. Async
* Messaging
* Event-driven
* Publisher-subscriber

### Architectural Patterns

* Layered
* Plug-in
* Client-server
* Master-slave
* Model-view-controller
* Service-oriented 
* Micro-services
* CQRS
* Data Streaming

### SDLC

* Waterfall
* Iterative
* Spiral
* Agile
* Lean
* DevOps

### Anti-patterns

* Spaghetti code
* Continuous obsolescence
* Lava flow
* Boat anchor
* Dead-end
* Not invented here syndrome
* Golden hummer

### Hosting and Operation

* Self-hosted
* IaaS
* PaaS
* Containers & Kubernetes
* Serverless
* CI/CD
* Configuration & secrets
* Monitoring & Logging
